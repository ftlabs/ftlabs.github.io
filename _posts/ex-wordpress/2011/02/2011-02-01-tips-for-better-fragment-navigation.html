---
layout: post
title: 'Tips for better fragment navigation'
date: 2011-02-19
categories: [ex-wordpress, technote]
permalink: /2011/02/tips-for-better-fragment-navigation/
author: andrew
---
<p><strong>This post was originally made on the Assanka blog.  Assanka was acquired by the Financial Times in January 2012, and became what is now FT Labs.  <a href="/about">Learn more</a>.</strong></p>
<p>Fragment navigation is becoming more and more popular.  Facebook practically runs their entire site on it, twitter search uses it, and Google recently defined a <a href="http://code.google.com/web/ajaxcrawling/docs/getting-started.html" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://code.google.com/web/ajaxcrawling/docs/getting-started.html', 'standard for making it crawl-able');">standard for making it crawl-able</a>.  JavaScript framework evangelists have rushed to produce plug-ins for their favourite tool-kit to make fragment navigation easier to implement.  Here I&#8217;ll discuss some of the issues we&#8217;ve dealt with as we started to use fragment navigation more often.</p>
<p><figure><img src="/assets/uploads/2011/02/new-1.png" alt="" title="Facebook example of fragment navigation" width="590" height="72" class="alignnone size-full wp-image-178" /></figure></p>
<p>The details of how fragment navigation (also hash navigation or hash fragment navigation) works have been <a href="http://www.novatek.com.au/news/fragment-navigation" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.novatek.com.au/news/fragment-navigation', 'covered');">covered</a> <a href="http://yensdesign.com/2008/11/creating-ajax-websites-based-on-anchor-navigation/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://yensdesign.com/2008/11/creating-ajax-websites-based-on-anchor-navigation/', 'extensively');">extensively</a> by <a href="http://msdn.microsoft.com/en-us/library/cc891506(VS.85).aspx" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://msdn.microsoft.com/en-us/library/cc891506(VS.85).aspx', 'others');">others</a>, and have been abstracted into various frameworks and toolkits.  A number are available for jQuery, such as:</p>
<ul>
<li><a href="http://plugins.jquery.com/project/history" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://plugins.jquery.com/project/history', 'History');">History</a></li>
<li><a>BBQ</a> (<a href="http://mattfrear.com/2010/03/20/enabling-browser-back-button-on-cascading-dropdowns-with-jquery-bbq-plugin/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://mattfrear.com/2010/03/20/enabling-browser-back-button-on-cascading-dropdowns-with-jquery-bbq-plugin/', 'tutorial');">tutorial</a>)</li>
<li><a href="http://www.asual.com/jquery/address/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.asual.com/jquery/address/', 'Address');">Address</a></li>
</ul>
<p>However, fragment navigation comes with a new set of challenges that we found ourselves having to address, so these will be the focus of this post.</p>
<h2>Full page alternatives</h2>
<p>Rather than changing all links to the form <code>&lt;a href="#!fragment/path/for/ajax"&gt;Link&lt;/a&gt;</code> and then detecting and acting upon fragment changes in javascript, we wanted to ensure that our links worked when they were copied and pasted into a new browser window, shared by email, or used with javascript disabled.  This meant making them into real URL links, and then progressively enhancing using a Javascript onclick handler to cancel the normal navigation action:</p>
<pre class="prettyprint linenums"><code>&lt;a href=&quot;/path/works/as/fragment/or/normal/page&quot; class=&quot;fragnav&quot;&gt;Link&lt;/a&gt;</code></pre>
<p>And some jQuery to hook the onclick handler on these fragment-navigation-compatible links, and convert them so that rather than navigating to the specified href, the browser changes it&#8217;s hash instead:</p>
<pre class="prettyprint linenums"><code>$(&quot;a.fragnav&quot;).click(function() {
  var href = this.href.replace(/^https?://[a-z0-9.]+/(.*#!)?/, '');
  location.hash = this.href;
  return false;
});</code></pre>
<p>Now you can either click the link with javascript enabled and get a dynamic AJAX behaviour, or right click then &#8216;Open in new window&#8217; (or click with javascript disabled) to get the full URL of the link to load normally.</p>
<h2>Caching</h2>
<p>When your user presses &#8216;back&#8217;, you can detect the fragment change and reload appropriate content &#8211; great.  But this is not as good as what you get from browsers&#8217; normal back button behaviour.  Normally, the previous page is cached, so it reappears almost instantly.  In the AJAX version, unless your fragment is just switching between different versions of content that are all preloaded, you may fire an AJAX request to load the content again.</p>
<p>It shouldn&#8217;t be necessary to reimplement caching yourself, since AJAX requests are subject to the same browser caching as normal page loads, but it&#8217;s easy to forget that you should include appropriate cache headers with your AJAX responses.  There are four HTTP headers that generally modify a browser&#8217;s caching behaviour:</p>
<ul>
<li>Cache-Control (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9', 'Docs');">Docs</a>)</li>
<li>Expires (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21', 'Docs');">Docs</a>)</li>
<li>ETag (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19', 'Docs');">Docs</a>)</li>
<li>Last-Modified (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29', 'Docs');">Docs</a>)</li>
</ul>
<p>Cache-Control and Expires are cache directive headers, telling the browser whether and for how long it may cache the resource.  Typically we set only Cache-Control, as it is more powerful and flexible, and Expires is generally unnecessary.</p>
<p>ETag and Last Modified are validators.  These allow the browser to make a conditional request to the server to find out if the resource has changed, and allow the server to respond with a simple 304 Not Modified if it hasn&#8217;t.  It&#8217;s often the case that your web server will add these automatically, and we prefer to avoid them entirely, relying on a single Cache-Control header to determine browser behaviour.</p>
<pre class="prettyprint linenums"><code>Cache-Control: max-age:60, public</code></pre>
<p>A nice trick for content that is personalised to an authenticated user is to include the <code>private</code> directive in your Cache-Control header, which allows the page to be cached, but only by the browser, not by any proxies along the way.</p>
<h2>Scroll position</h2>
<p>One of the things we found to be most difficult was managing scroll position.  Consider the default behaviour of a browser when navigating normally.  If you scroll down a page and click a link somewhere near the bottom, the browser loads the new page and displays it starting at the top.  However, if you then press the back button, it redisplays the last page you viewed and <strong>restores your scroll position for that page</strong>.  You may not have even noticed this, but if it stopped behaving this way you&#8217; get pretty annoyed soon enough!</p>
<p>So, if a user clicks one of your fragment links low down on your page, and the change you make to the page as a result would appear to the user to constitute a new page (obviously the point at which perception of &#8216;a new page&#8217; is triggered is subjective), consider scrolling the browser window back to the top.</p>
<p>But, you should not do this if the back button is used, because the browser will restore the user&#8217;s previous scroll position all by itself.  However, this becomes more complex if navigating forwards has considerably shortened the page content, and restoring the scroll position on back would require you to restore the content first in order for the necessary scroll offset to actually exist.  This is a bit confusing.  Here&#8217;s an illustration:</p>
<p><figure><img src="/assets/uploads/2011/02/ajaxnavgraphic1.png" alt="Illustration of problems with scroll position when using AJAX navigation" title="Illustration of problems with scroll position when using AJAX navigation" style='background-color: #004' class="aligncenter size-full wp-image-197" /></figure></p>
<p>So the solution we use is to remember the scroll position on every navigation action, and then restore it after repopulating the content if it looks like a backwards step.  You need to ensure you have got your caching rules right to support this otherwise the delay in refetching the content will make the browser reposition the scroll position twice &#8211; once by itself immediately, and again triggered by your JavaScript after the content has loaded.</p>
<h2>Loading pause</h2>
<p>Normally, the process of clicking a link and navigating to a new page involves the current page <strong>remaining on screen</strong> while the new page is being requested.  The browser only blanks it out when content starts to arrive for the new page.  The browser does provide some progress feedback immediately though, in the form of a wait mouse cursor or spinner in the browser chrome.</p>
<p>We aimed to replicate this experience for our AJAX-loaded views.  This means avoiding what seems like an obvious solution &#8211; empty the container when the link is clicked, and populate it when the AJAX response is received &#8211; because you&#8217;ll get a flash of blankness between the old content disappearing and new content replacing it.  Instead, the old content should remain, and the new content should simply replace it when the AJAX completes.</p>
<p>But this doesn&#8217;t provide progress feedback.  The risk is, the user will think nothing&#8217;s happened and will click the link again.  This tends to happen after about 2-3 seconds for most users, but AJAX calls normally don&#8217;t take anywhere near that long.  So we implemented a timeout that, after 250ms, would blank out the container, replacing the old content with a loading spinner.  If the AJAX completes within that time, it cancels the timer.</p>
<p>So, in most cases the user clicks a link and sees an almost immediate cut from old content to new with no flash of blankness.  In some cases they see the old content vanish and a loading spinner to reassure them that something is happening while we wait for the new content to come back.</p>
<p>If you regularly have edge cases where content takes more than a few seconds to load, you should consider moving on to a different kind of progress feedback, to avoid hitting that &#8220;it hasn&#8217;t worked&#8221; perception boundary.  The aim is to keep pushing that boundary back, keeping the user&#8217;s expectations in line with the performance that they&#8217;re getting from the site.  I like to think of this like a timeline:</p>
<p><figure><img src="/assets/uploads/2011/02/ajaxnavgraphic2.png" alt="Timeline of user perception when waiting for a navigation action to complete" title="Timeline of user perception when waiting for a navigation action to complete" width="515" height="169" style='background-color:#004' class="aligncenter size-full wp-image-199" /></figure></p>
<p>By providing better progress feedback, you can expand the &#8216;Expectation&#8217; phase and avoid the &#8216;Frustration&#8217; phase.  However, it&#8217;s also equally important that you don&#8217;t display a big piece of progress feedback for the entire operation to then complete in under 250ms &#8211; the feedback will be on screen for such a short period that the user will potentially be unsure about what happened and get anxious.  So be aware of the &#8216;instant&#8217; phase, when you should present no feedback at all.</p>
<h2>Inline Javascript</h2>
<p>Sometimes, it&#8217;s convenient to get both new HTML code and new Javascript when your user clicks a fragment link.  In our case, we wanted to set some Javascript globals in the response to allow javascript code already loaded on the page to better understand the content that had just been loaded.  Say the user has requested a page with a fragment that loads some search results.  We also want to tell the browser the search query that produced the results so that it can cache them, or populate the query into a search field that&#8217;s outside the fragment container, or something.</p>
<p>Normally, if you load content from a server using AJAX and append it to the DOM using innerHTML, any &lt;script&gt; sections in the HTML are not parsed by the browser&#8217;s JavaScript engine.  However, to make it do this is as simple as searching the returned source for &lt;script&gt; sections, and evaling them.  Make sure you properly filter and escape end user input before allowing it to be evaled though, otherwise you&#8217;re opening up your site to XSS attacks.</p>
<pre class="prettyprint linenums"><code>$('#main script').each(function() { eval(this.text); });</code></pre>
<h2>Command, Control and Shift modifier keys</h2>
<p>Power users like to open links in new tabs or windows.  In fact when faced with a list of links I often hold down Control and hit each link to turn to start preloading all the results into tabs which I can then review in turn without having to wait for each one to load.  To avoid annoying users, you need to ensure that whereever possible, control-click (or command-click) and shift-click (normally &#8216;new tab&#8217; and &#8216;new window&#8217; respectively) still work.</p>
<p>It&#8217;s easy to get lulled into a false sense of security by right clicking on your links and using the context menu to select &#8216;Open in new tab&#8217;.  This won&#8217;t run your onclick handler, so most likely will work if your link has a non-JavaScript href.  But using the keyboard CTRL key while clicking the link will fire the onclick event, and if you are cancelling the normal link navigation action by returning false, you&#8217;ll also be cancelling the new tab or new window request.  Ensuring that you don&#8217;t is quite straightforward (remember to include e.metaKey to detect the Command key on Macs):</p>
<pre class="prettyprint linenums"><code>if (e.shiftKey || e.ctrlKey || e.metaKey) return true;</code></pre>
<h2>Focus rectangles</h2>
<p>In most browsers, when you click a link, you get a small dotted rectangle around it.  This focus rectangle also appears if you tab through the actionable items on a page, to indicate which one would be followed if you pressed enter.  The problem is that if your link fires an AJAX action, and the link itself remains on screen after the action has completed, you&#8217;re left with a focus rectangle that you probably don&#8217;t want.</p>
<p>A bad way of dealing with this is to simply use CSS to set <code>outline:none</code> on all A tags.  This will certainly solve your problem, but kill all hope of keyboard navigation of your site.  Better is to study the way that this interaction happens normally, and then mimic it for your Ajax actions.  This is actually fairly easy to do generically:</p>
<pre class="prettyprint linenums"><code>(function() {

  // Keep track of which link element last had the focus (if browser does not support document.activeElement)
  if (!document.activeElement) {
    $(&quot;a&quot;).live('focus', function() {
      document.activeElement = this;
    });
  }

  // When any AJAX operation completes, blur any focused link
  $.ajaxSetup({complete:function(xhr, textStatus) {
    if (document.activeElement &amp;&amp; document.activeElement.is('a')) document.activeElement.blur();
  }});
}());</code></pre>
<p>Drop the above snippet into your javascript and you should find that focus rectangles still appear and stay visible while the ajax is running, but then vanish once it completes &#8211; perfect replica of the effect the user has learned to expect.  If your links don&#8217;t perform any AJAX, you&#8217;ll have to deal with those separately.</p>
<h2>Conclusion</h2>
<p>With all this to think about, you&#8217;d be forgiven for concluding that AJAX navigation simply isn&#8217;t worth the bother.  But bear with it &#8211; the benefits of being able to trivilally maintain state and load small fragments of content really makes a difference, both to the quality of the user experience and the load on your servers.</p>
